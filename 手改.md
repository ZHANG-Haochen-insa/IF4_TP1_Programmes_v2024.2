Rapport

2.1.1 Premier essai
Pin 19 f = 1000Khz
Pin 23 f = 1000Khz

根据xTaskCreate 两个信号同时输出


2.1.2
XTaskCreatePinnedCore 我们仅仅使用一个core进行输出，但是当我们两个任务的优先级不同，而且不会出现中断的问题的时候就会一直进行优先级高的task
Pin 19 f = 1000Khz 

为了避免这个问题，我们需要确保优先我们有足够的core执行task，另外要设定相应的interup来更改运行的task

当我们设定相同的优先级的时候，两个任务会交替执行，因为系统中

2.2.2a
这部分我们强制两个task都是用相同的core ，这样的话，我们会发现，当task 1即优先级高的task会保持一定频率执行，而task2则会根据task1的空闲的时候执行命令。
2.2.2.b
这里我们看到task2延迟运行，当niteration等于10000的时候，我们很难看出两个信号之间的时间差。不过当我们更改nbiterations的时候我们可以很明显的看到两次信号之间有一个时间差。因此我们看到对于task2来说 信号因为task1的占用被延迟进行了，但是对于下一次的信号保持不变，除非当iteration过大的时候会看到两个信号重叠到一起。

1. IF4_TP1_Q23a.ino

   * 代码目的:
      这个程序演示了如何使用 二进制信号量 (Binary Semaphore) 来实现两个任务之间的 直接同步或信号传递。
       * vTask1 是一个周期性任务（每 10ms 运行一次）。它在完成自己的工作后，会通过 xSemaphoreGive()
         "释放"（或称“给出”）一个信号量。
       * vTask2 则一直尝试通过 xSemaphoreTake() "获取" 这个信号量。只有当 vTask1 释放了信号量后，vTask2
         才能成功获取并执行它的工作。
       * 简单来说，vTask1 就像是发令员，vTask2 是运动员。vTask1 每次跑完一圈就挥旗发令，vTask2
         看到旗语后才开始跑。这确保了 vTask2 的动作发生在 vTask1 的某个动作之后。

   * 需要做什么:
      根据 PDF 的要求（2.3.2 Expérimentation 1），您 不需要修改代码。您需要做的是：
       1. 编译并上传程序。
       2. 使用示波器观察 oscillo1 (Task1) 和 oscillo2 (Task2) 的输出波形。
       3. 分析并解释：为什么 vTask2 的活动总是跟随在 vTask1 之后？这正是因为信号量起到了同步作用。

  2. IF4_TP1_Q23b.ino

   * 代码目的:
      这个程序旨在演示当多个任务访问 共享资源（Shared Resource） 时，如果没有保护机制会发生什么问题，并展示如何使用
   互斥锁 (Mutex) 来解决这个问题。
       * 程序中有两个任务 vTask1 和 vTask2，它们都会调用 alternate()
         函数。这个函数可以看作是一个“共享资源”，因为它会操作 GPIO 输出，如果两个任务同时调用，输出的波形会混乱。
       * 在初始代码中，用于加锁和解锁互斥锁（xSemaphoreTake(xMutex, ...) 和 xSemaphoreGive(xMutex))
         的代码行被注释掉了。

   * 需要做什么:
      根据 PDF 的要求（2.3.3 Expérimentation 2），您需要分两步操作：
       1. 第一步（观察问题）: 直接编译并运行当前的代码。通过示波器和串口监视器，您会发现两个任务的输出会互相干扰，因为
          它们在没有任何协调的情况下同时访问 alternate() 函数。这就是所谓的 竞态条件 (Race Condition)。
       2. 第二步（解决问题）:
           * 取消 以下代码行的注释：
               * vTask1 中: xSemaphoreTake(xMutex, portMAX_DELAY); 和 xSemaphoreGive(xMutex); (大约在 57-58 和 65-66
                 行)
               * vTask2 中: xSemaphoreTake(xMutex, portMAX_DELAY); 和 xSemaphoreGive(xMutex); (大约在 92-93 和 100-101
                 行)
           * 再次编译运行。您会发现，由于互斥锁的保护，两个任务现在会排队等待，每次只有一个任务能进入 alternate()
             函数的“临界区”，从而确保了共享资源的独占访问，输出波形变得有序。

  3. IF4_TP1_Q23c.ino

   * 代码目的:
      这个非常重要的实验旨在演示一个在实时系统中常见且危险的问题：优先级反转 (Priority Inversion)，并展示如何通过使用
   支持优先级继承 (Priority Inheritance) 的互斥锁 来解决它。
       * 程序创建了三个任务，并且都在同一个 CPU核心 (core 0) 上运行：
           * vTaskBasse (低优先级)
           * vTaskInter (中等优先级)
           * vTaskHaute (高优先级)
       * 初始代码使用 二进制信号量 作为锁。执行流程会是：
           1. 低优先级任务 vTaskBasse 获取信号量并开始执行一个长任务。
           2. 在 vTaskBasse 执行期间，中等优先级的 vTaskInter 准备就绪，由于其优先级更高，它会 抢占 vTaskBasse
              并开始运行。
           3. 在 vTaskInter 运行时，高优先级的 vTaskHaute 准备就绪，它想获取信号量，但信号量被 vTaskBasse 持有，所以
              vTaskHaute 被阻塞。
           4. 结果是：高优先级的任务 `vTaskHaute` 不得不等待中等优先级的 `vTaskInter` 和低优先级的 `vTaskBasse` 
              都执行完，它的优先级形同虚设，这就是优先级反转。

   * 需要做什么:
      根据 PDF 的要求（2.3.4 Expérimentation 3），您需要：
       1. 第一步（观察问题）: 直接编译运行当前代码，通过串口监视器观察各个任务的执行顺序和耗时。您会清楚地看到高优先级
          任务的执行被严重推迟了。
       2. 第二步（解决问题）:
           * 在 setup() 函数中，将创建信号量的代码 (大约在 168 行):
              xSemaphore = xSemaphoreCreateBinary();
           * 替换为:
              xSemaphore = xSemaphoreCreateMutex();
           * 再次编译运行。您会观察到，当高优先级任务 vTaskHaute
             因等待互斥锁而阻塞时，系统会自动将持有锁的低优先级任务 vTaskBasse 的优先级 临时提升 到与 vTaskHaute
             相同。这样，中等优先级的 vTaskInter 就无法抢占它了。vTaskBasse 会快速完成临界区代码，释放锁，然后
             vTaskHaute 就能立即获得锁并执行。这个问题就通过 优先级继承 解决了。
  总结一下，您接下来的操作应该是：
   1. Q23a: 只观察，不修改。
   2. Q23b: 先观察问题，然后通过取消注释来修复问题。
   3. Q23c: 先观察问题，然后通过将 xSemaphoreCreateBinary() 替换为 xSemaphoreCreateMutex() 来修复问题。