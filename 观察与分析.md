# IF4_TP1_Q21a - 观察与分析

这是我们第一次接触 FreeRTOS 的多任务调度。代码很简单：两个任务不停地翻转各自的 GPIO 引脚，就像在疯狂地开关电灯。任务1连接到GPIO19（黄色信号），优先级设为1；任务2连接到GPIO23（蓝色信号），优先级设为10。两个任务都没有任何延时或让出CPU的操作，纯粹是在拼命干活。

从示波器捕获的波形来看，实际运行结果和我们的预期基本吻合。因为使用的是 `xTaskCreate` 而不是固定核心的创建方式，调度器把两个任务分配到了ESP32的不同核心上。这样一来，尽管优先级差距很大，两个任务都能各自在自己的核心上全速运行。示波器上黄色和蓝色的方波都很密集，频率非常高，说明两个任务确实在并行执行，谁也不妨碍谁。

这个实验让我们看到了多核的威力 —— 即使优先级相差很大，只要在不同核心上运行，低优先级任务也不会被饿死。不过这也带来一个问题：如果想观察优先级抢占的效果，这样的设置显然不够。所以接下来的Q21b就要把两个任务强制绑定到同一个核心上，让它们真正竞争起来。

# Q21b — 观察与分析

Q21b 在 Q21a 的基础上做了几个关键改动。最重要的是使用 `xTaskCreatePinnedToCore` 把两个任务都绑定到了核心0，这下它们没法各自为政了，必须在同一个核心上竞争CPU时间。代码还保存了任务句柄（`Task1` 和 `Task2`），方便后面做一些控制操作。另外，引脚分配反过来了：任务1（黄色）现在用GPIO23，任务2（蓝色）用GPIO19。每个任务里加了个1000次的翻转循环，但依然没有任何延时。

运行两次测试后，示波器的波形非常直观地展示了优先级抢占的威力。串口显示两个任务都启动在核心0，但从波形看，蓝色信号（任务2，优先级10）的方波密密麻麻，频率很高；而黄色信号（任务1，优先级1）基本上就是一条直线，偶尔才会抖动一下。这就是典型的"饿死"现象 —— 低优先级任务几乎拿不到CPU，只能在高优先级任务偶尔短暂让出CPU的间隙里勉强执行一点点。

这个现象很好理解：两个任务都在同一个核心上，任务2的优先级是10，任务1只有1。虽然任务内部有1000次的循环，但循环结束后任务会立刻继续下一轮循环，从不主动休息。所以高优先级的任务2几乎永远处于就绪状态，调度器自然会一直选它运行。任务1只有在某些极其短暂的瞬间（比如任务2刚好完成一轮循环的那个时刻）才能抢到一点点CPU时间，所以波形上看起来就像是被"饿死"了。

这个实验让我们真切地感受到：在单核环境下，如果高优先级任务不主动让出CPU，低优先级任务基本没有出头之日。要解决这个问题，就需要在任务里加入延时或让出CPU的操作，这也是Q22a要做的事情。

# Q22a — 观察与分析

Q22a 是对 Q21b 问题的直接回应。代码做了两个关键改动：一是把任务分别绑定到不同的核心（任务1在核心0，任务2在核心1），二是在每轮翻转后加入了 `vTaskDelay`（任务1延时10ms，任务2延时20ms）。任务内部的翻转循环也增加到了30000次，让每个任务在休眠前能做更多的工作。

两次测试的波形让人眼前一亮。和Q21b完全不同，这次黄色和蓝色的信号都呈现出规律的脉冲形态。黄色信号（任务1）和蓝色信号（任务2）都有明显的"工作-休息-工作"的节奏：先是一阵密集的高频翻转（对应30000次循环），然后是一段平静期（对应延时），接着又开始下一轮。从示波器上看，两个任务的脉冲宽度不太一样，这是因为翻转次数虽然相同，但延时时间不同。

更有意思的是，虽然任务2的优先级还是10（比任务1高得多），但这次任务1不再被"饿死"了。原因很简单：两个任务运行在不同的核心上，各干各的，互不干扰。任务2就算优先级再高，也管不到核心0上的任务1。同时，`vTaskDelay` 的加入也很关键 —— 它让任务主动进入阻塞状态，把CPU时间让给其他需要运行的任务。即使是在同一核心上，这种机制也能保证低优先级任务有机会执行。

这个实验告诉我们两件事：第一，多核架构确实能有效避免优先级导致的饿死问题；第二，合理使用延时函数是实时系统设计的基本功，它不仅能节省CPU资源，还能让任务调度变得更加公平和可预测。

# Q22b — 观察与分析

Q22b 在 Q22a 的基础上做了个重要的改进：用 `vTaskDelayUntil` 替换了 `vTaskDelay`。虽然看起来只是换了个函数，但意义完全不同。`vTaskDelay` 是"从现在开始延时N毫秒"，而 `vTaskDelayUntil` 是"等到距离上次唤醒时刻N毫秒后再醒来"。后者能保证任务以精确的周期运行，不会因为任务执行时间的波动而累积误差。同时，翻转次数从30000减少到10000，让每个工作周期短一些，方便观察周期性的特征。

两次测试的结果和Q22a类似，但波形看起来更加规整。黄色信号（任务1，周期10ms）和蓝色信号（任务2，周期20ms）都呈现出非常规律的脉冲串。因为翻转次数减少了，每个脉冲的宽度比Q22a窄一些，但间隔更加稳定。仔细观察可以发现，任务1的脉冲更密集（周期10ms），任务2的脉冲稍微稀疏（周期20ms），这正是我们设定的周期关系。

这个实验的重点不在于优先级或核心分配，而在于展示周期性任务的实现方式。在真实的实时系统中，很多任务需要以固定的频率运行，比如传感器采样、控制算法计算、通信协议处理等。`vTaskDelayUntil` 就是为这种场景设计的：它能保证即使任务执行时间有微小波动，下一次唤醒时刻也不会漂移，从长期来看能维持精确的周期。从示波器上看，两个任务的脉冲间隔非常均匀，没有抖动或漂移，这就是周期性调度的理想效果。

通过这四个实验（Q21a到Q22b），我们完整地体验了FreeRTOS的任务调度机制：从多核并行到单核抢占，从饿死现象到公平调度，从简单延时到精确周期控制。这些概念和技术是理解实时系统的基础，也是后续更复杂实验的铺垫。

# Q24 — 观察与分析：当中断来敲门

Q24把我们带入了一个新的领域：硬件中断。如果说之前的实验是让任务们在CPU的舞台上你争我抢，那么中断就像是一个突然闯入的"VIP客人"，它一出现，所有人都得停下来为它让路。这个实验巧妙地展示了中断、信号量和任务之间的三角关系。

代码的设计挺有意思。在setup函数里，有个不太优雅但很直接的做法：程序进入了一个无限循环，每隔300ms翻转一次GPIO12引脚的输出状态。这个引脚通过物理连线连接到GPIO5（中断输入引脚），于是形成了一个"自激系统" —— 自己给自己制造中断信号。每次GPIO12的状态改变（从高到低，或从低到高），GPIO5就会检测到电平变化，触发中断例程。

中断例程 `interruptRoutine()` 的任务很明确：一旦被触发，它就调用 `xSemaphoreGiveFromISR()` 释放一个二进制信号量。这就像是在门口按了一下门铃，告诉Task2"有活干了"。Task2一直在那里等着，通过 `xSemaphoreTake()` 阻塞自己，只有当信号量被释放后才会醒来，执行一段GPIO翻转的工作，然后重新进入等待状态。

与此同时，Task1完全独立地运行在核心0上，每隔1秒（1000ms）做一次自己的GPIO翻转工作。它和中断系统没有任何直接关系，就像一个定期巡逻的保安，不管外面发生什么，都按自己的节奏走。

从示波器捕获的波形来看，结果非常清晰。黄色信号（CH1，Task1）呈现出规律的脉冲串，每个脉冲串对应一次完整的翻转工作（10次迭代，每次延时5ms），然后是很长的沉默期（1000ms）。时间刻度是1秒每格，所以每个格子里大概能看到一个Task1的脉冲串。

蓝色信号（CH2，Task2）则要频繁得多。因为GPIO12每300ms就翻转一次状态，而 `attachInterrupt` 设置的触发模式是 `CHANGE`（电平变化就触发），所以每300ms就会触发两次中断（一次上升沿，一次下降沿） —— 实际上大约每150ms就能看到一次Task2的活动。从波形上看，CH2的脉冲分布得比较密集，虽然每个脉冲本身很短（只有10次翻转，每次5ms，总共约100ms），但重复频率高。

串口监视器的输出也印证了这个过程。每次打印 `current=1` 或 `current=0`，紧接着就是 `[INFO] interruptRoutine()` 和 `[INFO] vTask2 called`。这三条信息几乎是成套出现的，说明电平变化、中断触发、Task2被唤醒这三件事是紧密衔接的。

这个实验的精妙之处在于展示了实时系统中异步事件的处理方式。中断是硬件世界和软件世界的桥梁 —— 当外部事件发生时（比如按钮按下、传感器数据就绪、定时器溢出），CPU需要立即响应，而不能等到某个任务慢慢轮询。但中断服务例程（ISR）又不能做太复杂的事情，因为它会阻塞整个系统。所以最佳实践就是：ISR里只做最简单的事（比如释放信号量），然后让一个任务去完成真正的工作。这种"中断+信号量+任务"的模式，是嵌入式系统设计的经典范式。

从优先级的角度看，Task2的优先级（10）虽然低于Task1（20），但这不重要，因为它们运行在不同的核心上。Task1在核心0，Task2在核心1，各司其职，互不干扰。即使Task2的优先级更低，也能在中断触发后立即执行，因为它在自己的核心上没有竞争对手。

这个实验让我们体会到：在嵌入式系统中，不是所有事件都能提前规划好时间表。中断机制让系统能够对不可预知的外部事件做出快速响应，而信号量则优雅地将这种响应从中断上下文传递到任务上下文，既保证了响应速度，又保持了代码的清晰和安全。

# Q25 — 观察与分析：任务间的传话筒

Q25把我们从中断的世界带回到任务之间的协作，但这次的协作方式更加丰富：不再是简单的"通知一下就完事"，而是真正的"传递数据"。这里的主角是队列（Queue），它就像任务之间的一个信箱，一个任务可以往里面放信，另一个任务可以从里面取信。

代码的结构比之前清晰了很多。Task1是个"生产者"，它每隔500ms就会生成一个数据 —— 一个不断翻倍的整数（从1开始，每次乘以2：1, 2, 4, 8, 16...）。生成数据后，Task1尝试用 `xQueueSendToBack()` 把这个数字放进队列。如果队列还有空位，就能成功放入，然后Task1会执行一段GPIO翻转工作（10次迭代，每次5ms），顺便在串口打印"a envoyé X"（已发送X）；如果队列满了，发送失败，Task1就会打印"PAS PU ENVOYER X"（无法发送X）。

Task2是个"消费者"，它的工作节奏要快得多 —— 每10ms就醒来一次，先查看队列里有多少个待处理的数据（`uxQueueMessagesWaiting`），然后尝试用 `xQueueReceive()` 从队列头部取出一个数据。这个函数的超时参数设置为100ms，意思是"如果队列空了，我愿意等100ms；如果还是没有数据，就返回失败"。如果成功收到数据，Task2会打印"reçu X"（收到X），然后执行一段GPIO翻转工作；如果没收到，就打印"RIEN EU A LIRE"（没有东西可读）。

队列的大小被设置为5（`TAILLE_MAX`），这是个关键参数。它决定了系统的"缓冲能力" —— 如果Task1生产数据的速度远远超过Task2消费的速度，队列很快就会被填满，Task1就只能等待或者放弃发送。反过来，如果Task2消费得太快，队列就会空着，Task2就会频繁地空转，浪费CPU时间。

从代码的时间参数来看，Task1每500ms生产一个数据，Task2每10ms检查一次队列。理论上，Task2的检查频率是Task1生产频率的50倍，所以队列应该很少会满，但也很少会堆积太多数据。大部分时候，Task2醒来的时候要么刚好有一个数据在等着，要么队列是空的。

两个任务被分配到不同的核心：Task1在核心0（优先级20），Task2在核心1（优先级10）。这样的设计保证了即使优先级不同，它们也能各自独立运行，不会因为优先级抢占而影响数据处理的及时性。

从功能上看，这个实验模拟了一种常见的生产者-消费者模式。在实际应用中，这种模式无处不在：传感器采集数据（生产者）然后送给数据处理算法（消费者）；网络接收数据包（生产者）然后交给协议栈解析（消费者）；用户界面产生事件（生产者）然后分发给事件处理器（消费者）。队列在其中起到了缓冲和解耦的作用 —— 生产者和消费者不需要同步工作，也不需要知道对方的存在，只需要通过队列这个中间人来交换数据。

FreeRTOS的队列还有个巧妙的设计：它是线程安全的。多个任务可以同时往同一个队列发送或接收数据，内核会自动处理竞争和同步问题。而且，当队列满了或空了的时候，任务可以选择阻塞等待，这样既不会丢失数据，也不会浪费CPU时间忙等待。

队列的大小选择也是一门艺术。太小了，容易满，会导致生产者频繁阻塞或丢数据；太大了，浪费内存，而且可能积累过时的数据。在这个实验中，大小为5是个合理的选择 —— 既能应对短暂的生产速度波动，又不会占用太多RAM。

虽然我们没有Q25的示波器图像，但可以想象：黄色信号（Task1）应该是每500ms出现一次短暂的脉冲串，对应发送数据后的GPIO翻转工作；蓝色信号（Task2）的出现频率会更随机一些，取决于队列里是否有数据 —— 如果有，Task2就会立即处理并产生脉冲；如果没有，Task2就会静默地等待。

这个实验让我们明白：任务之间不仅需要同步（像之前的信号量那样），还需要通信（传递实际的数据）。队列作为FreeRTOS提供的经典通信原语，优雅地解决了这个问题。它既能传递数据，又能实现同步；既保证了线程安全，又提供了灵活的阻塞和超时机制。掌握队列的使用，是编写复杂多任务系统的必备技能。

# Q26 — 观察与分析：三任务会合点

Q26要求我们实现一个任务同步的会合点（rendez-vous）机制。程序需要创建三个任务：任务1和任务2并行执行各自的工作，任务3必须等待前两个任务都完成后才能开始执行。这个问题可以使用计数信号量来解决：任务1和任务2完成后各自释放一次信号量，任务3连续获取两次信号量来确认前两个任务都已完成。这种同步模式在需要汇总多个并行计算结果的场景中非常常见，比如多传感器数据融合或并行任务的结果汇总。

（完）
