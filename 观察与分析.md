# IF4_TP1_Q21a - 观察与分析

## 程序功能概述

这是第一个FreeRTOS多任务程序,创建了两个具有不同优先级的并发任务。
你好你好
## 程序配置

- **任务1优先级**: 1 (低优先级)
- **任务2优先级**: 10 (高优先级)
- **输出引脚**:
  - oscillo1 = GPIO 19 (任务1)
  - oscillo2 = GPIO 23 (任务2)

## 代码关键点

### 任务1 (vTask1)
```cpp
void vTask1( void *pvParameters )
{
  bool etat = LOW;
  Serial.printf("vTask1 / core %d started\n", xPortGetCoreID());

  for( ;; )  // 无限循环
  {
    // 快速翻转GPIO 19的状态
    if (etat == HIGH)
      etat = LOW;
    else
      etat = HIGH;
    digitalWrite(oscillo1, etat);
  }
}
```

### 任务2 (vTask2)
```cpp
void vTask2( void *pvParameters )
{
  bool etat = LOW;
  Serial.printf("vTask2 / core %d started\n", xPortGetCoreID());

  for( ;; )  // 无限循环
  {
    // 快速翻转GPIO 23的状态
    if (etat == HIGH)
      etat = LOW;
    else
      etat = HIGH;
    digitalWrite(oscillo2, etat);
    //delay(50);  // 注释掉的延迟
  }
}
```

## 预期观察结果

### 1. 示波器观察

#### 现象:
- **通道1 (GPIO 19)**: 方波信号,频率较高
- **通道2 (GPIO 23)**: 方波信号,频率较高
- 两个信号的频率应该**相似**或**接近**

#### 原因分析:
由于ESP32有**双核处理器**:
- 任务1和任务2很可能被分配到**不同的核心**上
- 即使优先级不同,两个任务可以**真正并行**执行
- 因此两个GPIO引脚都会以最快速度翻转

如果强制在同一核心上:
- **任务2 (优先级10)** 会**抢占**任务1 (优先级1)
- 任务1几乎不会执行,GPIO 19可能保持不变或很少翻转
- 任务2会独占CPU,GPIO 23快速翻转

### 2. 串口监视器观察

#### 现象:
打开串口监视器(波特率 115200)时,可能会看到:
```
Start
[INFO] Startup finished
vTask1 / core 0 started
vTask2 / core 1 started
```
或者类似的输出,显示两个任务在不同核心上启动。

#### 可能的问题:
**串口输出可能混乱或不完整**,因为:
- 两个任务都在**无限循环**中快速执行
- 没有任何延迟或同步
- 没有保护串口这个**共享资源**
- 如果两个任务同时尝试向串口输出,可能会产生**竞争条件**

## 为什么会出现这样的结果?

### ESP32双核架构
- ESP32有**两个Xtensa 32位LX6微处理器核心**
- FreeRTOS会自动在两个核心间**分配任务**
- 默认情况下,任务可能被分配到任意核心

### 任务调度策略
1. **相同优先级**: 时间片轮转(Round Robin)
2. **不同优先级**: 高优先级任务抢占低优先级任务
3. **多核**: 如果有空闲核心,任务可以并行运行

### 本程序的情况
- 两个任务都在**无限循环**中,永不休眠
- 没有`delay()`或`vTaskDelay()`,不会主动让出CPU
- 如果在不同核心上,两个任务**真正并行**执行
- 如果在同一核心上,高优先级任务会**饿死**低优先级任务

## 实验验证

### 验证1: 查看任务运行的核心
在串口监视器中观察输出:
- `vTask1 / core X started` - 任务1运行在核心X
- `vTask2 / core Y started` - 任务2运行在核心Y
- 如果 X ≠ Y,说明任务在不同核心上

### 验证2: 强制单核运行
修改setup()函数,使用`xTaskCreatePinnedToCore`:
```cpp
xTaskCreatePinnedToCore(vTask1, "vTask1", 10000, NULL, task1_prio, NULL, 0);
xTaskCreatePinnedToCore(vTask2, "vTask2", 10000, NULL, task2_prio, NULL, 0);
```
此时两个任务都在核心0上,观察示波器:
- GPIO 23应该快速翻转(高优先级任务)
- GPIO 19可能几乎不动(低优先级任务被饿死)

## 关键学习点

1. **优先级只在同一核心上有意义** - 多核系统中,任务可以真正并行
2. **无限循环任务会独占CPU** - 需要主动让出CPU
3. **共享资源需要保护** - 串口、GPIO等都是共享资源
4. **FreeRTOS自动调度** - 除非明确指定,否则任务会被自动分配到核心

## 下一步

在Q21b中,我们会:
- 实验不同的优先级配置
- 观察相同优先级时的行为
- 学习如何避免任务饿死问题

## Q21b — 观察与分析（简洁）

- 主要变化：
  - 使用 `xTaskCreatePinnedToCore` 将两个任务固定到核心 0（强制单核运行）。
  - 保存了任务句柄 `Task1` 和 `Task2`（第6个参数传入地址），便于后续控制（挂起、删除、修改优先级）。
  - 每个任务内部包含一个 1000 次的快速翻转循环（busy loop），没有阻塞或延时。
  - 与 Q21a 相比，两个 oscillo 引脚在代码中互换（`oscillo1=23`, `oscillo2=19`）。

- 观察到的事件：
  - 串口输出可能显示两条任务启动信息，并指明它们均运行在 core 0。
  - 在示波器上：当 `task2_prio` 大于 `task1_prio` 时，代表高优先级的任务（对应的 GPIO）会高速翻转；低优先级 GPIO 几乎不变或极少翻转（被饿死）。
  - 若将两个任务设为相同优先级或把高优先级降低，则两路信号会出现交替或时间片轮转的现象。

- 简要分析：
  - 因为任务被固定在同一核心，优先级的抢占效果非常明显：高优先级任务占用 CPU，低优先级任务无法获得运行机会。 
  - 内部 1000 次快速翻转为忙等（busy loop），不会主动让出 CPU；即使循环有有限次数，循环结束后任务仍会立即继续进入下一个循环，保持就绪并继续占用 CPU。
  - 保存任务句柄是一个改进（比 Q21a 直接传 NULL 更灵活），便于后续做实验性操作。

- 建议（短）：
  - 若想避免低优先级任务被饿死，在循环中加入 `vTaskDelay(pdMS_TO_TICKS(x))` 或 `taskYIELD()`。
  - 若想演示多核并行，可将任务不固定到同一核（或分别 pin 到不同核）；若想演示抢占，则 pin 到同一核。
  - 根据任务实际需要调整栈大小，并用任务句柄做可控实验（挂起/恢复/改变优先级）。

为验证并解决 Q21b 中观察到的抢占与饿死问题，Q22a 将引入让出 CPU 与共享资源保护的实验。

## Q22a — 观察与分析（简洁）

- 主要改动：
  - 在任务循环中加入主动阻塞或让出调用（示例：`vTaskDelay(pdMS_TO_TICKS(n))` 或 `taskYIELD()`），使高优先级任务不会无限占用 CPU。
  - 将两个任务在不同实验中设为相同优先级或不同优先级，以观察时间片轮转与抢占两种调度行为的差异。
  - 演示使用任务句柄动态改变优先级、挂起/恢复任务，验证调度器对状态变化的即时响应。
  - 引入对共享串口的互斥保护（例如 FreeRTOS 的 mutex），避免并发打印造成的输出混乱。

- 观察到的事件：
  - 加入 `vTaskDelay` 后，在示波器上两路信号会交替出现，低优先级任务恢复可见的翻转频率；
  - 将优先级调整为相同值时，若在同一核上会观察到时间片轮转导致的近似相同频率；若在不同核上仍会并行且频率接近最大值；
  - 使用 mutex 保护串口后，串口输出变得有序且不再出现明显竞争导致的乱码或丢失。

- 简要分析：
  - `vTaskDelay` 等阻塞调用会把任务置为阻塞态，从而让调度器运行其他就绪任务，避免低优先级任务被完全饿死；
  - 动态改变优先级或挂起任务可以用来演示抢占的即时影响，是理解调度器行为的有力手段；
  - 保护共享资源是并发编程的基本要求，串口 mutex 是一个典型且必要的改进。

- 建议（短）：
  - 在实验中记录不同配置下示波器上两路信号的频率并对比（例如：无延时、1 ms 延时、10 ms 延时）；
  - 调整并测量栈大小以确保任务稳定，避免运行时堆栈溢出；
  - 将部分实验固定到同一核心，部分实验分配到不同核心，直观比较多核并行与单核抢占的差异。
