# IF4_TP1_Q21a - 观察与分析（简洁）

Q21a 是一个入门级的 FreeRTOS 实验：两个独立任务在 GPIO 上以 busy-loop 快速翻转电平，用示波器与串口观察调度与优先级的影响。

- 配置要点：`oscillo1 = GPIO19`（任务1，优先级1），`oscillo2 = GPIO23`（任务2，优先级10），串口 115200 用于调试输出。

- 代码特点：每个任务在启动时打印核心信息（`xPortGetCoreID()`），随后进入无限循环不断切换输出电平；任务创建使用 `xTaskCreate`，示例故意设置不同优先级以观察抢占效应。

- 预期观察：
  - 若任务被分配到不同核心，两路可并行，示波器上呈现高速方波；
  - 若强制同核（或在单核场景），高优先级任务会抢占 CPU，低优先级任务可能被饿死，导致对应 GPIO 几乎不翻转；
  - 串口打印在并发情况下会竞争，建议使用互斥保护。 

- 简要建议：在任务循环中加入 `vTaskDelay(pdMS_TO_TICKS(n))` 或 `taskYIELD()`，保存任务句柄并使用 mutex 保护串口以便进行可控实验。

基于此，Q21b 将把任务 pin 到同核并保存句柄以放大并演示单核抢占与饿死问题。

# Q21b — 观察与分析（简洁）

- 主要变化：
  - 使用 `xTaskCreatePinnedToCore` 将两个任务固定到核心 0（强制单核运行）。
  - 保存了任务句柄 `Task1` 和 `Task2`（第6个参数传入地址），便于后续控制（挂起、删除、修改优先级）。
  - 每个任务内部包含一个 1000 次的快速翻转循环（busy loop），没有阻塞或延时。
  - 与 Q21a 相比，两个 oscillo 引脚在代码中互换（`oscillo1=23`, `oscillo2=19`）。

- 观察到的事件：
  - 串口输出可能显示两条任务启动信息，并指明它们均运行在 core 0。
  - 在示波器上：当 `task2_prio` 大于 `task1_prio` 时，代表高优先级的任务（对应的 GPIO）会高速翻转；低优先级 GPIO 几乎不变或极少翻转（被饿死）。
  - 若将两个任务设为相同优先级或把高优先级降低，则两路信号会出现交替或时间片轮转的现象。

- 简要分析：
  - 因为任务被固定在同一核心，优先级的抢占效果非常明显：高优先级任务占用 CPU，低优先级任务无法获得运行机会。 
  - 内部 1000 次快速翻转为忙等（busy loop），不会主动让出 CPU；即使循环有有限次数，循环结束后任务仍会立即继续进入下一个循环，保持就绪并继续占用 CPU。
  - 保存任务句柄是一个改进（比 Q21a 直接传 NULL 更灵活），便于后续做实验性操作。

- 建议（短）：
  - 若想避免低优先级任务被饿死，在循环中加入 `vTaskDelay(pdMS_TO_TICKS(x))` 或 `taskYIELD()`。
  - 若想演示多核并行，可将任务不固定到同一核（或分别 pin 到不同核）；若想演示抢占，则 pin 到同一核。
  - 根据任务实际需要调整栈大小，并用任务句柄做可控实验（挂起/恢复/改变优先级）。

为验证并解决 Q21b 中观察到的抢占与饿死问题，Q22a 将引入让出 CPU 与共享资源保护的实验。

# Q22a — 观察与分析（简洁）

- 主要改动：
  - 在任务循环中加入主动阻塞或让出调用（示例：`vTaskDelay(pdMS_TO_TICKS(n))` 或 `taskYIELD()`），使高优先级任务不会无限占用 CPU。
  - 将两个任务在不同实验中设为相同优先级或不同优先级，以观察时间片轮转与抢占两种调度行为的差异。
  - 演示使用任务句柄动态改变优先级、挂起/恢复任务，验证调度器对状态变化的即时响应。
  - 引入对共享串口的互斥保护（例如 FreeRTOS 的 mutex），避免并发打印造成的输出混乱。

- 观察到的事件：
  - 加入 `vTaskDelay` 后，在示波器上两路信号会交替出现，低优先级任务恢复可见的翻转频率；
  - 将优先级调整为相同值时，若在同一核上会观察到时间片轮转导致的近似相同频率；若在不同核上仍会并行且频率接近最大值；
  - 使用 mutex 保护串口后，串口输出变得有序且不再出现明显竞争导致的乱码或丢失。

- 简要分析：
  - `vTaskDelay` 等阻塞调用会把任务置为阻塞态，从而让调度器运行其他就绪任务，避免低优先级任务被完全饿死；
  - 动态改变优先级或挂起任务可以用来演示抢占的即时影响，是理解调度器行为的有力手段；
  - 保护共享资源是并发编程的基本要求，串口 mutex 是一个典型且必要的改进。

- 建议（短）：
  - 在实验中记录不同配置下示波器上两路信号的频率并对比（例如：无延时、1 ms 延时、10 ms 延时）；
  - 调整并测量栈大小以确保任务稳定，避免运行时堆栈溢出；
  - 将部分实验固定到同一核心，部分实验分配到不同核心，直观比较多核并行与单核抢占的差异。

# Q22b — 观察与分析（简洁）

- 主要改动：
  - 在 Q22a 的基础上，Q22b 侧重于“同步与可控切换”的演示：引入串口互斥（mutex）、在任务间通过任务句柄实施挂起/恢复，并演示动态改变任务优先级的效果（`vTaskPrioritySet`）。
  - 在部分实验场景中，把高频 busy-loop 用短的批次 + `vTaskDelay` 交替替换，以产生更易测量的方波并允许精确统计每个任务的活动时间比。
  - 记录并对比多组数据：不同延时设置、同核 vs 异核、动态优先级切换前后任务在示波器与串口的表现。

- 观察到的事件：
  - 使用 mutex 保护串口后，串口输出变得线性有序，任务间日志不再互相错行或丢失；
  - 通过任务句柄挂起低优先级任务可以立刻停止其 GPIO 翻转，恢复时可观测到恢复瞬间的脉冲；
  - 动态降低高优先级或提升低优先级会立即改变示波器上两路信号的占空与频率分配，验证了调度器对优先级变化的即时响应；
  - 在同核实验中即使存在 `vTaskDelay`，高优先级仍更容易获取较多 CPU 时间片（取决于 delay 长短），而在异核实验中两路可更公平地并行执行。

- 简要分析：
  - Mutex 能解决共享资源冲突，但不能代替良好的任务调度策略：互斥保护不会影响任务何时被调度，只是保证资源访问的原子性与顺序性；
  - 通过挂起/恢复演示任务可控性，也证明任务句柄是做实验时的重要工具；
  - 动态优先级修改显示了优先级对 CPU 分配的直接影响（同核时更明显），这在设计实时系统时既是工具也是风险来源，需要结合阻塞与延时策略一起使用。

- 建议（短）：
  - 在记录实验数据时同时保存示波器截图与串口日志，便于定量比较不同配置的效果；
  - 设计实验时把 `vTaskDelay` 的值做为自变量（例如 0、1、5、10 ms）并测量每组下两个 GPIO 的翻转频率与占空比；
  - 在实现 mutex/优先级控制时注意最小化临界区长度，避免因持有 mutex 而影响调度延迟；
  - 在最终演示文档中附上关键代码片段（mutex 使用、vTaskPrioritySet 示例、挂起/恢复调用），以便复现实验。

（完）
