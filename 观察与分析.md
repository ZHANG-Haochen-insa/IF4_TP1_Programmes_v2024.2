# IF4_TP1_Q21a - 观察与分析

这是我们第一次接触 FreeRTOS 的多任务调度。代码很简单：两个任务不停地翻转各自的 GPIO 引脚，就像在疯狂地开关电灯。任务1连接到GPIO19（黄色信号），优先级设为1；任务2连接到GPIO23（蓝色信号），优先级设为10。两个任务都没有任何延时或让出CPU的操作，纯粹是在拼命干活。

从示波器捕获的波形来看，实际运行结果和我们的预期基本吻合。因为使用的是 `xTaskCreate` 而不是固定核心的创建方式，调度器把两个任务分配到了ESP32的不同核心上。这样一来，尽管优先级差距很大，两个任务都能各自在自己的核心上全速运行。示波器上黄色和蓝色的方波都很密集，频率非常高，说明两个任务确实在并行执行，谁也不妨碍谁。

这个实验让我们看到了多核的威力 —— 即使优先级相差很大，只要在不同核心上运行，低优先级任务也不会被饿死。不过这也带来一个问题：如果想观察优先级抢占的效果，这样的设置显然不够。所以接下来的Q21b就要把两个任务强制绑定到同一个核心上，让它们真正竞争起来。

# Q21b — 观察与分析

Q21b 在 Q21a 的基础上做了几个关键改动。最重要的是使用 `xTaskCreatePinnedToCore` 把两个任务都绑定到了核心0，这下它们没法各自为政了，必须在同一个核心上竞争CPU时间。代码还保存了任务句柄（`Task1` 和 `Task2`），方便后面做一些控制操作。另外，引脚分配反过来了：任务1（黄色）现在用GPIO23，任务2（蓝色）用GPIO19。每个任务里加了个1000次的翻转循环，但依然没有任何延时。

运行两次测试后，示波器的波形非常直观地展示了优先级抢占的威力。串口显示两个任务都启动在核心0，但从波形看，蓝色信号（任务2，优先级10）的方波密密麻麻，频率很高；而黄色信号（任务1，优先级1）基本上就是一条直线，偶尔才会抖动一下。这就是典型的"饿死"现象 —— 低优先级任务几乎拿不到CPU，只能在高优先级任务偶尔短暂让出CPU的间隙里勉强执行一点点。

这个现象很好理解：两个任务都在同一个核心上，任务2的优先级是10，任务1只有1。虽然任务内部有1000次的循环，但循环结束后任务会立刻继续下一轮循环，从不主动休息。所以高优先级的任务2几乎永远处于就绪状态，调度器自然会一直选它运行。任务1只有在某些极其短暂的瞬间（比如任务2刚好完成一轮循环的那个时刻）才能抢到一点点CPU时间，所以波形上看起来就像是被"饿死"了。

这个实验让我们真切地感受到：在单核环境下，如果高优先级任务不主动让出CPU，低优先级任务基本没有出头之日。要解决这个问题，就需要在任务里加入延时或让出CPU的操作，这也是Q22a要做的事情。

# Q22a — 观察与分析

Q22a 是对 Q21b 问题的直接回应。代码做了两个关键改动：一是把任务分别绑定到不同的核心（任务1在核心0，任务2在核心1），二是在每轮翻转后加入了 `vTaskDelay`（任务1延时10ms，任务2延时20ms）。任务内部的翻转循环也增加到了30000次，让每个任务在休眠前能做更多的工作。

两次测试的波形让人眼前一亮。和Q21b完全不同，这次黄色和蓝色的信号都呈现出规律的脉冲形态。黄色信号（任务1）和蓝色信号（任务2）都有明显的"工作-休息-工作"的节奏：先是一阵密集的高频翻转（对应30000次循环），然后是一段平静期（对应延时），接着又开始下一轮。从示波器上看，两个任务的脉冲宽度不太一样，这是因为翻转次数虽然相同，但延时时间不同。

更有意思的是，虽然任务2的优先级还是10（比任务1高得多），但这次任务1不再被"饿死"了。原因很简单：两个任务运行在不同的核心上，各干各的，互不干扰。任务2就算优先级再高，也管不到核心0上的任务1。同时，`vTaskDelay` 的加入也很关键 —— 它让任务主动进入阻塞状态，把CPU时间让给其他需要运行的任务。即使是在同一核心上，这种机制也能保证低优先级任务有机会执行。

这个实验告诉我们两件事：第一，多核架构确实能有效避免优先级导致的饿死问题；第二，合理使用延时函数是实时系统设计的基本功，它不仅能节省CPU资源，还能让任务调度变得更加公平和可预测。

# Q22b — 观察与分析

Q22b 在 Q22a 的基础上做了个重要的改进：用 `vTaskDelayUntil` 替换了 `vTaskDelay`。虽然看起来只是换了个函数，但意义完全不同。`vTaskDelay` 是"从现在开始延时N毫秒"，而 `vTaskDelayUntil` 是"等到距离上次唤醒时刻N毫秒后再醒来"。后者能保证任务以精确的周期运行，不会因为任务执行时间的波动而累积误差。同时，翻转次数从30000减少到10000，让每个工作周期短一些，方便观察周期性的特征。

两次测试的结果和Q22a类似，但波形看起来更加规整。黄色信号（任务1，周期10ms）和蓝色信号（任务2，周期20ms）都呈现出非常规律的脉冲串。因为翻转次数减少了，每个脉冲的宽度比Q22a窄一些，但间隔更加稳定。仔细观察可以发现，任务1的脉冲更密集（周期10ms），任务2的脉冲稍微稀疏（周期20ms），这正是我们设定的周期关系。

这个实验的重点不在于优先级或核心分配，而在于展示周期性任务的实现方式。在真实的实时系统中，很多任务需要以固定的频率运行，比如传感器采样、控制算法计算、通信协议处理等。`vTaskDelayUntil` 就是为这种场景设计的：它能保证即使任务执行时间有微小波动，下一次唤醒时刻也不会漂移，从长期来看能维持精确的周期。从示波器上看，两个任务的脉冲间隔非常均匀，没有抖动或漂移，这就是周期性调度的理想效果。

通过这四个实验（Q21a到Q22b），我们完整地体验了FreeRTOS的任务调度机制：从多核并行到单核抢占，从饿死现象到公平调度，从简单延时到精确周期控制。这些概念和技术是理解实时系统的基础，也是后续更复杂实验的铺垫。

（完）
