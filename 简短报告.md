# FreeRTOS 多任务调度实验报告

## 2.1.1 Premier essai (Q21a)

### 代码分析

本实验使用 `xTaskCreate` 创建两个任务，每个任务不停翻转各自的GPIO引脚。Task1绑定到GPIO19，优先级为1；Task2绑定到GPIO23，优先级为10。由于使用的是 `xTaskCreate` 而非核心绑定的创建方式，FreeRTOS调度器将两个任务分配到ESP32的不同核心上运行。

### 图像分析

![Q21a示波器波形](img/q21a.jpg)

**图像观察**：示波器显示Pin 19和Pin 23都输出约1000kHz的方波信号。两个信号同时输出且频率相同，说明两个任务在不同核心上并行执行，互不干扰，即使优先级差距很大也不会出现抢占现象。

## 2.1.2 Deuxième essai (Q21b)

### 代码分析

本实验使用 `xTaskCreatePinnedToCore` 将两个任务都绑定到核心0，强制它们在同一个核心上竞争CPU时间。Task1优先级为1，Task2优先级为10。当两个任务运行在同一核心且优先级不同时，高优先级任务会持续占用CPU，导致低优先级任务几乎无法执行。只有当设置相同优先级时，系统才会让任务交替执行。

### 图像分析

![Q21b第一次测试](img/q21b_1.jpg)

**图像观察**：Pin 19的信号频率约为1000kHz，呈现密集的方波，而另一信号几乎是平直的线。这说明高优先级的Task会一直占用核心0，低优先级任务被"饿死"，几乎得不到执行机会。

![Q21b第二次测试](img/q21b_2.jpg)

**图像观察**：波形与第一次测试类似，进一步验证了单核环境下优先级抢占的效果。低优先级任务只能在高优先级任务极短暂的让出CPU瞬间勉强执行一点，波形上几乎看不到活动。

## 2.2.2a Premier essai (Q22a)

### 代码分析

本实验在Q21b基础上做了关键改进：将两个任务分别绑定到不同核心（Task1在核心0，Task2在核心1），并在每轮30000次翻转后加入延时（Task1延时10ms，Task2延时20ms）。多核分配消除了优先级抢占问题，而 `vTaskDelay` 的加入使任务周期性地让出CPU，实现了规律的"工作-休息"模式。

### 图像分析

![Q22a第一次测试](img/q22a_1.jpg)

**图像观察**：两个信号都呈现规律的脉冲串形态，黄色和蓝色信号都有明显的"工作-休息"节奏。由于两个任务运行在不同核心上，它们可以并行执行而互不干扰，即使优先级不同也都能正常运行。

![Q22a第二次测试](img/q22a_2.jpg)

**图像观察**：波形与第一次测试一致，进一步证明了 `vTaskDelay` 的作用。两个任务虽然优先级不同，但通过主动让出CPU实现了公平调度，避免了饿死现象。

## 2.2.2b Deuxième essai (Q22b)

### 代码分析

本实验用 `vTaskDelayUntil` 替换了 `vTaskDelay`，实现周期性任务调度。`vTaskDelayUntil` 能保证任务以精确的周期运行，不会因执行时间波动而累积误差。翻转次数减少到10000次，使每个工作周期更短。当nIteration=10000时，两个信号之间的时间差很难观察；但更改nIterations值后，可以明显看到Task2因Task1占用而产生的延迟，不过下一次信号周期保持不变，除非iteration过大导致信号重叠。

### 图像分析

![Q22b第一次测试](img/q22b_1.jpg)

**图像观察**：两个信号呈现非常规律的脉冲串，Task1（周期10ms）的脉冲更密集，Task2（周期20ms）的脉冲稍稀疏。周期性调度使得信号间隔均匀稳定，没有抖动或漂移现象。

![Q22b第二次测试](img/q22b_2.jpg)

**图像观察**：波形与第一次测试保持一致，验证了 `vTaskDelayUntil` 的精确周期控制能力。即使Task2因Task1的执行而延迟启动，其周期性仍然得到保证，体现了实时系统的可预测性。
