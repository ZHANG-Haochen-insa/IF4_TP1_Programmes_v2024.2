# TP1 - ESP32上的FreeRTOS实时编程

## 项目描述
本仓库包含IF4/5实时编程TP1的所有程序 - 在ESP32微控制器上使用FreeRTOS进行实时多任务编程。

**目标**: 熟悉FreeRTOS提供的实时多任务机制。

## 前置要求
- Arduino IDE v2 (程序无法在v1上运行)
- ESP32开发板
- 示波器用于观察信号
- 用于连接GPIO引脚到示波器的导线(+ GND接地线)

## 启动开发环境
```bash
/opt/arduino-ide_2.3.2_Linux_64bit/arduino-ide
```

## 程序结构

### 2.1 并发任务

#### **IF4_TP1_Q21a** - 并发任务初体验
- **描述**: 两个具有不同优先级的任务 (task1_prio=1, task2_prio=10)
- **使用引脚**: GPIO 19 (oscillo1), GPIO 23 (oscillo2)
- **观察内容**:
  - 描述示波器上的结果
  - 观察串口监视器
  - 理解优先级对任务调度的影响

#### **IF4_TP1_Q21b** - 相同优先级的变体
- **与Q21a的区别**: 研究优先级的影响
- **实验内容**:
  - 观察不同优先级时的行为
  - 修改优先级使其相同
  - 分析对调度的影响

### 2.2 周期性任务

#### **IF4_TP1_Q22a** - 第一种方法 (使用delay)
- **方法**: 使用 `delay()` 创建周期性任务
- **问题**:
  - 测量任务1和任务2的实际周期
  - 在单核和双核上测试
  - 评估这是否是实现周期性任务的好方法

#### **IF4_TP1_Q22b** - 第二种方法 (使用vTaskDelay)
- **方法**: 使用 `vTaskDelay()` 实现更好的周期控制
- **重要变量**: `nb_iterations` - 模拟工作的迭代次数
- **实验内容**:
  - 与Q22a对比
  - 逐步增加 `nb_iterations` 并观察行为
  - 找出可以预测问题的判断标准

### 2.3 任务间同步

#### 核心概念
- **二进制信号量**: 用于两个任务间的同步(绿灯信号)
- **互斥锁(Mutex)**: 保护共享资源的特殊信号量,支持优先级继承

#### **IF4_TP1_Q23a** - 信号量入门
- **描述**: 使用信号量进行同步的基础示例
- **目标**: 理解同步机制

#### **IF4_TP1_Q23b** - 保护共享资源
- **当前状态**: 互斥锁代码被注释 - 共享资源访问未受保护
- **问题**: 并发访问共享资源
- **需要的修改**:
  ```cpp
  // 取消以下行的注释:
  // 第57-58, 65-66行 (vTask1)
  // 第92-93, 100-101行 (vTask2)
  ```
- **配置**: 任务在不同核心上运行 (Task1在核心0, Task2在核心1)

#### **IF4_TP1_Q23c** - 优先级反转与继承
- **任务**: 3个不同优先级的任务 (高=20, 中=10, 低=5)
- **场景**:
  - 低优先级任务访问共享资源
  - 高优先级任务等待该资源
  - 中优先级任务在两者之间执行
- **需要的修改** (第168行):
  ```cpp
  // 替换:
  xSemaphore = xSemaphoreCreateBinary();
  // 为:
  xSemaphore = xSemaphoreCreateMutex();
  ```
- **观察**: 二进制信号量与互斥锁的区别(优先级继承)

### 2.4 中断

#### **IF4_TP1_Q24** - 中断处理
- **描述**: 中断机制入门
- **工具**: 示波器 + 串口监视器

### 2.5 任务间通信

#### **IF4_TP1_Q25** - 消息队列(Queues)
- **描述**: 通过队列实现任务间通信
- **额外工作**:
  - 测试 http://tvaira.free.fr/esp32/esp32-freertos.html 的示例7
  - 修改参数并评论结果

### 2.6 同步 - 最终练习

#### **需要创建** - 3个任务的会合点
创建一个新程序,包含:
- **任务1**: 执行某项工作
- **任务2**: 并行执行另一项工作
- **任务3**: 等待任务1和2完成后才开始

**提示**:
- `uxSemaphoreGetCount()` : http://www.openrtos.net/uxSemaphoreGetCount.html
- `xSemaphoreCreateCounting()` : 计数信号量(可选)

## 使用的GPIO引脚

| 程序 | 示波器1 | 示波器2 |
|------|---------|---------|
| Q21a | GPIO 19 | GPIO 23 |
| Q21b | GPIO 19 | GPIO 23 |
| Q22a | GPIO 19 | GPIO 23 |
| Q22b | GPIO 19 | GPIO 23 |
| Q23a | -       | -       |
| Q23b | GPIO 23 | GPIO 19 |
| Q23c | -       | -       |
| Q24  | 待确认  | -       |
| Q25  | 待确认  | -       |

**⚠️ 重要**: 别忘了连接接地线(GND)到示波器!

## 涉及的FreeRTOS概念

### 创建任务
```cpp
xTaskCreate(
    vTask1,          // 任务函数
    "vTask1",        // 名称(任意)
    10000,           // 内存大小(以字为单位)
    NULL,            // 传递的参数
    task1_prio,      // 静态优先级
    NULL             // 句柄(可选)
);
```

### 在指定核心上创建任务
```cpp
xTaskCreatePinnedToCore(
    vTask1,          // 函数
    "Task1",         // 名称
    10000,           // 栈大小
    NULL,            // 参数
    task1_prio,      // 优先级
    &Task1,          // 句柄
    0                // 核心编号(0或1)
);
```

### 延迟函数
- `delay(ms)`: 简单的阻塞延迟
- `vTaskDelay(pdMS_TO_TICKS(ms))`: 延迟并释放CPU

### 信号量和互斥锁
```cpp
// 创建二进制信号量
xSemaphore = xSemaphoreCreateBinary();

// 创建互斥锁(带优先级继承)
xMutex = xSemaphoreCreateMutex();

// 获取信号量/互斥锁
xSemaphoreTake(xSemaphore, portMAX_DELAY);

// 释放信号量/互斥锁
xSemaphoreGive(xSemaphore);
```

## 实验报告
- **格式**: 手写
- **截止时间**: 实验课后整整1周
- **内容**: 观察结果、解释、问题答案
- **重要性**: 对TP2和考试有用

## 评估标准
教师将评估:
1. 工作准备情况
2. TP期间的进度
3. 手写实验报告

## 有用的资源
- FreeRTOS文档: https://www.freertos.org/
- 栈大小: https://www.freertos.org/FAQMem.html#StackSize
- ESP32 + FreeRTOS示例: http://tvaira.free.fr/esp32/esp32-freertos.html
- 计数信号量: http://www.openrtos.net/uxSemaphoreGetCount.html

## 重要说明
- 所有程序在setup()中都以`vTaskDelete(NULL)`结束,因为Arduino任务不再需要
- `loop()`函数是空的但编译必需
- ESP32有2个核心,允许真正的并行执行
- 优先级数值越高,优先级越高(task_prio=10 > task_prio=1)

## 故障排除
- 如果串口监视器没有输出: 检查波特率(115200)
- 如果示波器没有显示: 检查GPIO连接和GND
- 如果编译失败: 确认使用的是Arduino IDE v2

## 各程序详细分析

### Q21a - 并发任务观察要点
1. **示波器观察**: 两个方波信号,频率应相近(双核并行)
2. **串口输出**: 显示任务运行的核心编号
3. **关键学习**: 优先级在多核系统中的作用,任务调度基础

### Q22a vs Q22b - 周期性任务对比
- **Q22a**: 使用delay(),周期不准确,占用CPU
- **Q22b**: 使用vTaskDelay(),更精确,释放CPU给其他任务

### Q23系列 - 同步机制进阶
- **Q23a**: 基础信号量使用
- **Q23b**: 互斥锁保护共享资源(需修改代码)
- **Q23c**: 优先级继承机制演示(需修改信号量类型)

### Q24 - 中断
理解中断服务程序(ISR)与任务的交互

### Q25 - 队列通信
学习FreeRTOS队列进行任务间数据传递

### Q26 - 综合练习
设计并实现多任务同步,综合运用所学知识

## 学习路径建议

1. **第一步**: 运行Q21a和Q21b,理解任务和优先级
2. **第二步**: 对比Q22a和Q22b,掌握周期性任务
3. **第三步**: 完成Q23系列,理解同步和互斥
4. **第四步**: 学习Q24和Q25,掌握中断和通信
5. **第五步**: 独立完成Q26,综合应用

祝学习顺利!
